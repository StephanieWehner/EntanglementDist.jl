<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Known distillation/filtering schemes · Entanglement Distillation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="assets/documenter.js"></script><script src="siteinfo.js"></script><script src="../versions.js"></script><link href="assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Entanglement Distillation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" action="search.html"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="index.html">Optimizing Entanglement Distillation</a></li><li><a class="toctext" href="intro.html">Introduction</a></li><li><a class="toctext" href="optimize.html">Tools for optimizing distillation</a></li><li><a class="toctext" href="quantum.html">Tools for creating and manipulating quantum states</a></li><li class="current"><a class="toctext" href="schemes.html">Known distillation/filtering schemes</a><ul class="internal"></ul></li><li><a class="toctext" href="states.html">Special quantum states</a></li><li><a class="toctext" href="examplePPT.html">Using the PPT Relaxation method</a></li><li><a class="toctext" href="exampleKEXT.html">Using the method of k extensions</a></li><li><a class="toctext" href="exampleSeesaw.html">Using the seesaw method</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href="schemes.html">Known distillation/filtering schemes</a></li></ul><a class="edit-page" href="https://github.com/StephanieWehner/EntanglementDist.jl/tree/7e57086b53251d90d683f8a55b4a44e515cebde8/src/schemes.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Known distillation/filtering schemes</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Known-distillation/filtering-schemes-1" href="#Known-distillation/filtering-schemes-1">Known distillation/filtering schemes</a></h1><p>Compute how well several known entanglement distillation schemes perform on specific input states. We also implement a simple filtering scheme and provide function for computing the performance of general filtering schemes given the relevant measurement operators. The functions computing the choi states of said filtering protocols can be used to test the performance of the seesaw method.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EntanglementDist.DEJMPSParam" href="#EntanglementDist.DEJMPSParam"><code>EntanglementDist.DEJMPSParam</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>(F, p_succ) = DEJMPSParam(rho)</code></p><p>Determines the performance of DEJMPS for two copies of the input state <em>rho</em> (consisting of two qubits) and returns the fidelity and success probability achieved. The procedure optimises over local single qubit rotations that permute the bell diagonal coefficients before the CNOTs to achieve the highest output fidelity. returns (F_out, p_succ)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EntanglementDist.BBPSSWParam" href="#EntanglementDist.BBPSSWParam"><code>EntanglementDist.BBPSSWParam</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>(F, p_succ) = BBPSSWParam(F)</code></p><p>Determines the performance of BBPSSW for two copies of the input state (consisting of two qubits) with fidelity <em>F</em> each. returns (F_out, p_succ)</p></div><div><p><code>(F, p_succ) = BBPSSWParam(rho)</code></p><p>Determines the performance of BBPSSW for two copies of the input state <em>rho</em> (consisting of two qubits). returns (F_out, p_succ)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EntanglementDist.EPLDParam" href="#EntanglementDist.EPLDParam"><code>EntanglementDist.EPLDParam</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>(F, p_succ) = EPLDParam(p, pd)</code></p><p>Determines the performance of EPL-D for rStateCorrPhase. The inputs are the <em>p</em> and <em>pd</em> parameters of rStateCorrPhase. returns (F_out, p_succ)</p></div><div><p><code>(F, p_succ) = EPLDParam(rho)</code></p><p>Determines the performance of EPL-D for an arbitrary bipartite state of dimensions nA=nB=4. returns (F_out, p_succ)</p></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EntanglementDist.filtering" href="#EntanglementDist.filtering"><code>EntanglementDist.filtering</code></a> — <span class="docstring-category">Function</span>.</div><div><p>`<code>(rhoQC,P,F,psucc) = filtering(rhoAB,eps)</code></p><p>Implements the filtering protocol on input state <em>rho</em> with filtering parameter <em>eps</em>. This filtering protocol is designed to work well on states of the form p * EPR + (1-p) |10&gt;&lt;10|.</p><p>Input:</p><ul><li><p><em>rhoAB</em> 2x2 state to be filtered</p></li><li><p><em>eps</em> filtering parameter, smaller eps typically means higher fidelity but lower probability of success</p></li></ul><p>Output:</p><ul><li><p><em>rhoQC</em> filtered state with flags: Q=hatA, hatB contains the output state, C  F_A,F_B contains the flags (1 success, 0 failure)</p></li><li><p><em>P</em> projector specifying how Alice and Bob determine success |11&gt;&lt;11|, both succeed</p></li><li><p><em>F</em> fidelity achieved for the given input state</p></li><li><p><em>psucc</em> probability of success</p></li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EntanglementDist.filteringMakeChoi" href="#EntanglementDist.filteringMakeChoi"><code>EntanglementDist.filteringMakeChoi</code></a> — <span class="docstring-category">Function</span>.</div><div><p>`<code>(choiA, choiB) = filteringMakeChoi(eps)</code></p><p>Computes the choi states for Alice and Bob in the filtering protocol with filtering parameter <em>eps</em>. This filtering protocol is designed to work well on states of the form p * EPR + (1-p) |10&gt;&lt;10|.</p><p>Input:</p><ul><li><p><em>eps</em> filtering parameter, smaller eps typically means higher fidelity but lower probability of success</p></li></ul><p>Output:</p><ul><li><p><em>choi</em> state for Alice hatA,FA,A</p></li><li><p><em>choi</em> state for Bob hatB,FB,B</p></li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EntanglementDist.measureScheme" href="#EntanglementDist.measureScheme"><code>EntanglementDist.measureScheme</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>(rhoQC, F, psucc) = measureScheme(rhoAB, k, MokAlice, MfailAlice, MokBob, MfailBob, fokAlice, ffailAlice, fokBob, ffailBob, P)</code></p><p>Implements a distillation scheme in which Alice and Bob perform the indicated measurement and then output a success or failure flag individually. Global success is determined by the projector P which may compare the to local flag registers.</p><p>Input:</p><ul><li><p><em>rhoAB</em> input state to be distilled</p></li><li><p><em>k</em> local dimension of the max entangled state to be produced</p></li><li><p><em>MokAlice</em> Kraus operator corresponding to Alice success</p></li><li><p><em>MfailAlice</em> Kraus operator corresponding to Alice failure</p></li><li><p><em>MokBob</em> Kraus operator corresponding to Bob success</p></li><li><p><em>MfailBob</em> Kraus operator corresponding to Bob failure</p></li><li><p><em>fokAlice</em> flag Alice outputs for success</p></li><li><p><em>ffailAlice</em> flag Alice outputs for failure</p></li><li><p><em>fokBob</em> flag Bob outputs for success</p></li><li><p><em>ffailBob</em> flag Bob outputs for failure</p></li><li><p><em>P</em> projector determining for which joint flags they declare global success</p></li></ul><p>Output:</p><ul><li><p><em>rhoQC</em> output state where Q=hatA, hatB is the output state and C=F_A,F_B the flag register</p></li><li><p><em>F</em> fidelity achieved</p></li><li><p><em>psucc</em> success probability achieved</p></li></ul></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="EntanglementDist.measureSchemeMakeChoi" href="#EntanglementDist.measureSchemeMakeChoi"><code>EntanglementDist.measureSchemeMakeChoi</code></a> — <span class="docstring-category">Function</span>.</div><div><p><code>choiState = measureSchemeMakeChoi(MokAlice, MfailAlice, fokAlice, ffailAlice)</code></p><p>Computes the choi state of a measuring distillation/filtering protocol of one party: Outputs choi_QA where A is a copy of the input and Q is the output of the distillation map A-&gt;hatA, fA</p><p>Input:</p><ul><li><p><em>MokAlice</em> Kraus operator corresponding to Alice success</p></li><li><p><em>MfailAlice</em> Kraus operator corresponding to Alice failure</p></li><li><p><em>fokAlice</em> flag Alice outputs for success</p></li><li><p><em>ffailAlice</em> flag Alice outputs for failure</p></li></ul></div></section><footer><hr/><a class="previous" href="quantum.html"><span class="direction">Previous</span><span class="title">Tools for creating and manipulating quantum states</span></a><a class="next" href="states.html"><span class="direction">Next</span><span class="title">Special quantum states</span></a></footer></article></body></html>
